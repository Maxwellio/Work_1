================================================================================
ОПИСАНИЕ ПРОЦЕССА РАБОТЫ ЛОГИН-ФОРМЫ, ВАЛИДАЦИИ И АВТОРИЗАЦИИ
================================================================================
(от открытия страницы до переадресации на home-страницу)

================================================================================
1. СТРУКТУРА ПРИЛОЖЕНИЯ
================================================================================

Frontend (React + Vite), порт 5173
Backend (Spring Boot), порт 8095
Прокси: /api → http://localhost:8095

================================================================================
2. ТОЧКА ВХОДА — ЗАГРУЗКА ПРИЛОЖЕНИЯ
================================================================================

Файл: frontend/index.html
Содержимое: подключает script src="/src/main.jsx"

Файл: frontend/src/main.jsx
Метод: ReactDOM.createRoot().render()
Выполняет:
  - Оборачивает приложение в <BrowserRouter> для маршрутизации
  - Рендерит компонент <App />
Вызывает: App

---

Файл: frontend/src/App.jsx
Компонент: App
Выполняет:
  - Оборачивает маршруты в <AuthProvider> (контекст авторизации)
  - Определяет маршруты:
    - /login → компонент Login
    - / → ProtectedRoute → Layout → Home
    - * → Navigate to "/"
Рендерит: AuthProvider, внутри него Routes и Route

================================================================================
3. AUTH PROVIDER — ГЛОБАЛЬНОЕ СОСТОЯНИЕ АВТОРИЗАЦИИ
================================================================================

Файл: frontend/src/context/AuthContext.jsx

--- Компонент AuthProvider ---
Метод: AuthProvider({ children })
Состояние: user (null или { username, roles, userId }), loading
Методы контекста:
  - fetchUser() — запрашивает текущего пользователя, обновляет user
  - logout() — выполняет logout API, сбрасывает user
  - setUser, loading
Провайдер передаёт value = { user, setUser, loading, fetchUser, logout }

--- Хук useAuth ---
Метод: useAuth()
Выполняет: возвращает контекст AuthContext (user, fetchUser, logout и т.д.)
Используется в: Login, ProtectedRoute, Layout и др.

================================================================================
4. ОТКРЫТИЕ СТРАНИЦЫ /login
================================================================================

Маршрут /login рендерит компонент Login.

Файл: frontend/src/pages/Login.jsx
Компонент: Login

--- Хук useAuth ---
Вызов: const { user, fetchUser } = useAuth()
Получает: объект user (null или данные пользователя), функцию fetchUser

--- useEffect (при монтировании) ---
Вызов: useEffect(() => { fetchUser().then(...); return () => { cancelled = true } }, [fetchUser])
Выполняет:
  1. Вызывает fetchUser() из AuthContext
  2. fetchUser → apiGetCurrentUser() → GET /api/current-user
  3. При завершении: setSessionChecked(true)
  4. В cleanup: отмена через cancelled (предотвращает setState после размонтирования)

Порядок:
  Login монтируется → useEffect запускается → fetchUser() → GET /api/current-user

--- Ветвление по sessionChecked ---
Если !sessionChecked: рендер "Проверка авторизации…"

--- Ветвление по user ---
Если user !== null (уже авторизован): return <Navigate to="/" replace />
  → редирект на главную без показа формы

--- Иначе: рендер формы ---
Состояния: username, password, error, submitting
Поля: Логин (input type="text"), Пароль (input type="password")
Атрибуты валидации HTML5: required на обоих полях

================================================================================
5. API: ПРОВЕРКА ТЕКУЩЕГО ПОЛЬЗОВАТЕЛЯ (GET /api/current-user)
================================================================================

Файл: frontend/src/api/index.js
Функция: getCurrentUser()
Выполняет:
  - fetch('/api/current-user', { method: 'GET', credentials: 'include' })
  - credentials: 'include' — отправляет cookie JSESSIONID
Передаёт: ничего (только cookie)
Получает:
  - 401 → возвращает null
  - !res.ok → throw Error
  - 200 → res.json() → { username, roles, userId }

Прокси Vite перенаправляет /api → http://localhost:8095/api

---

Backend: Spring Security
Файл: backend/src/main/java/patrubki/config/SecurityConfig.java
Правило: requestMatchers("/api/current-user", "GET").permitAll()
  → endpoint доступен без авторизации

---

Backend: контроллер
Файл: backend/src/main/java/patrubki/controller/AuthController.java

Метод: getCurrentUser()
  - Аннотация: @GetMapping("/current-user")
  - Получает: Authentication из SecurityContextHolder
  - Проверяет: auth == null || !auth.isAuthenticated() || "anonymousUser"
    → return ResponseEntity.status(401)
  - Извлекает: username = auth.getName(), roles из auth.getAuthorities()
  - Запрос к БД: userRepository.findByUsername(username) → userId
  - Возвращает: ResponseEntity.ok(CurrentUserDto(username, roles, userId))

Файл: backend/src/main/java/patrubki/dto/CurrentUserDto.java
Поля: username, roles (List<String>), userId (Integer)

================================================================================
6. ОТПРАВКА ФОРМЫ — НАЖАТИЕ "ВОЙТИ"
================================================================================

Файл: frontend/src/pages/Login.jsx

--- Обработчик handleSubmit ---
Вызов: onSubmit={handleSubmit} на форме

Метод: handleSubmit(e)
Параметр: e — событие submit
Выполняет:
  1. e.preventDefault() — отмена стандартной отправки формы
  2. setError('')
  3. setSubmitting(true)
  4. const res = await apiLogin(username.trim(), password)
  5. Обработка ответа (см. ниже)
  6. finally: setSubmitting(false)

Передаёт в apiLogin: username.trim(), password (сырой пароль)

================================================================================
7. API: LOGIN (POST /api/login)
================================================================================

Файл: frontend/src/api/index.js
Функция: login(username, password)
Выполняет:
  - fetch('/api/login', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({ username, password }).toString()
    })
  - body: "username=...&password=..." (form-urlencoded)
Передаёт: username, password в теле запроса
Получает: Response (res.ok, res.status) — тело ответа не парсится

================================================================================
8. BACKEND: SPRING SECURITY — ОБРАБОТКА LOGIN
================================================================================

Файл: backend/src/main/java/patrubki/config/SecurityConfig.java

--- Разрешения ---
requestMatchers("/api/login", "POST").permitAll() — без авторизации

--- formLogin ---
  loginProcessingUrl: "/api/login"
  usernameParameter: "username"
  passwordParameter: "password"

Spring Security использует UsernamePasswordAuthenticationFilter:
  1. Перехватывает POST /api/login
  2. Извлекает username и password из тела (form-urlencoded)
  3. Вызывает UserDetailsService.loadUserByUsername(username)

--- UserDetailsService ---
Файл: backend/src/main/java/patrubki/security/UserDetailsServiceImpl.java

Метод: loadUserByUsername(String username)
  - Вызов: userRepository.findByUsernameIgnoreCaseAndActive(username, 1)
  - Репозиторий: UserRepository (JpaRepository)
  - Поиск: пользователь с данным username (без учёта регистра) и active = 1
  - Если не найден: throw UsernameNotFoundException
  - Маппинг роли: roleNmToAuthority(entity.getRole().getNm())
    - "Пользователь" → ROLE_USER
    - "Администратор" → ROLE_ADMIN
  - Возвращает: User.builder()
      .username(entity.getUsername())
      .password(entity.getPassword())  // хэш BCrypt
      .authorities(authorities)
      .disabled(...)
      .build()

Spring Security затем:
  4. Сравнивает пароль: BCryptPasswordEncoder.matches(rawPassword, encodedPassword)
  5. При успехе: создаёт Authentication, сохраняет в SecurityContext, сессию (JSESSIONID)
  6. successHandler: response 200, body {"ok": true}
  7. При ошибке: failureHandler → 401, body {"error": "Unauthorized"}

================================================================================
9. ВАЛИДАЦИЯ (СВОДКА)
================================================================================

Frontend:
  - HTML5: required на полях Логин и Пароль
  - e.preventDefault() — форма не уходит по умолчанию
  - username.trim() — обрезка пробелов перед отправкой

Backend:
  - UsernamePasswordAuthenticationFilter: извлечение username/password
  - UserDetailsServiceImpl: проверка наличия пользователя (active=1)
  - UsernameNotFoundException при отсутствии
  - BCryptPasswordEncoder: проверка пароля
  - AuthenticationException при неверном пароле

================================================================================
10. ОБРАБОТКА ОТВЕТА LOGIN НА FRONTEND
================================================================================

Файл: frontend/src/pages/Login.jsx, handleSubmit

  if (!res.ok):
    if (res.status === 401) → setError('Неверный логин или пароль')
    иначе → setError('Ошибка входа. Попробуйте позже.')
    return

  catch (err) → setError('Ошибка соединения. Проверьте подключение.')

  При успехе (res.ok):
    1. await fetchUser()
       - GET /api/current-user с credentials
       - Spring Security видит JSESSIONID, сессия авторизована
       - AuthController.getCurrentUser() возвращает CurrentUserDto
       - setUser(u) в AuthContext
    2. navigate('/', { replace: true })
       - переадресация на главную страницу

================================================================================
11. ПЕРЕХОД НА ГЛАВНУЮ (/) — ProtectedRoute
================================================================================

Файл: frontend/src/App.jsx
Маршрут: path="/" element={<ProtectedRoute><Layout><Home /></Layout></ProtectedRoute>}

Файл: frontend/src/components/ProtectedRoute.jsx
Компонент: ProtectedRoute({ children })

--- useEffect ---
  if (user !== null) → setInitialCheckDone(true), return
  иначе: fetchUser().then(() => setInitialCheckDone(true))

--- Ветвление ---
  Если !initialCheckDone || (loading && user === null):
    рендер "Проверка авторизации…"
  Если user === null:
    return <Navigate to="/login" state={{ from: location }} replace />
  Иначе:
    return children (Layout с Home)

На этом этапе user уже установлен (из fetchUser после login), поэтому:
  - initialCheckDone становится true
  - user !== null
  - рендерится Layout с Home

================================================================================
12. HOME СТРАНИЦА
================================================================================

Файл: frontend/src/pages/Home.jsx
Компонент: Home
Рендерится внутри Layout.

Файл: frontend/src/components/Layout.jsx
Компонент: Layout
Содержит: header, навигацию, вывод children (Home)

================================================================================
13. ПОРЯДОК ВЫЗОВОВ (ПОЛНАЯ ПОСЛЕДОВАТЕЛЬНОСТЬ)
================================================================================

=== При открытии /login (неавторизованный пользователь) ===
1. main.jsx: render App
2. App.jsx: AuthProvider → Routes → Route /login → Login
3. Login: useAuth() → fetchUser, user
4. Login useEffect: fetchUser()
5. AuthContext.fetchUser: apiGetCurrentUser()
6. api/index.js getCurrentUser: GET /api/current-user
7. Proxy → backend:8095
8. SecurityConfig: permitAll для /api/current-user
9. AuthController.getCurrentUser: auth — anonymous → 401
10. getCurrentUser возвращает null
11. AuthContext: setUser(null)
12. Login: sessionChecked = true, user = null → показ формы

=== При отправке формы (успешный вход) ===
1. Пользователь вводит логин/пароль, нажимает "Войти"
2. handleSubmit(e): e.preventDefault()
3. apiLogin(username.trim(), password)
4. api/index.js login: POST /api/login, body form-urlencoded
5. Proxy → backend:8095
6. SecurityConfig: UsernamePasswordAuthenticationFilter
7. UserDetailsServiceImpl.loadUserByUsername(username)
8. UserRepository.findByUsernameIgnoreCaseAndActive → UserEntity
9. Spring: BCryptPasswordEncoder.matches(password, entity.getPassword())
10. successHandler: 200, {"ok": true}, Set-Cookie: JSESSIONID=...
11. login() возвращает res, res.ok = true
12. handleSubmit: await fetchUser()
13. apiGetCurrentUser: GET /api/current-user, credentials: include (cookie)
14. Spring: сессия авторизована → AuthController возвращает CurrentUserDto
15. fetchUser: setUser(u)
16. handleSubmit: navigate('/', { replace: true })
17. React Router: переход на /
18. ProtectedRoute: user !== null → рендер Layout → Home

=== При открытии /login (уже авторизованный) ===
1. Login монтируется
2. useEffect: fetchUser()
3. GET /api/current-user с cookie → 200, { username, roles, userId }
4. setUser(u), sessionChecked = true
5. Login: if (user) return <Navigate to="/" replace />
6. Редирект на главную

================================================================================
14. СПИСОК ФАЙЛОВ И МЕТОДОВ
================================================================================

Frontend:
  main.jsx                      — render(), точка входа
  App.jsx                       — AuthProvider, Routes, Route
  context/AuthContext.jsx       — AuthProvider, fetchUser, logout, useAuth
  pages/Login.jsx               — Login, useEffect, handleSubmit
  components/ProtectedRoute.jsx — ProtectedRoute, useEffect
  api/index.js                  — login(), getCurrentUser(), logout()

Backend:
  config/SecurityConfig.java    — filterChain(), passwordEncoder()
  controller/AuthController.java — getCurrentUser()
  security/UserDetailsServiceImpl.java — loadUserByUsername(), roleNmToAuthority()
  repository/UserRepository.java — findByUsernameIgnoreCaseAndActive()
  dto/CurrentUserDto.java       — конструктор, геттеры

================================================================================
15. ПЕРЕДАЧА ДАННЫХ (СВОДНАЯ ТАБЛИЦА)
================================================================================

| Этап                    | Откуда      | Куда              | Что передаётся                    | Что возвращается                    |
|-------------------------|-------------|-------------------|-----------------------------------|-------------------------------------|
| GET /api/current-user   | Login/ProtectedRoute | Backend      | Cookie JSESSIONID                 | 401 или { username, roles, userId } |
| POST /api/login         | Login       | Backend           | username, password (form-urlencoded) | 200 {"ok":true} или 401             |
| loadUserByUsername      | Spring      | UserDetailsServiceImpl | username                    | UserDetails (username, password hash, authorities) |
| BCryptPasswordEncoder   | Spring      | —                 | rawPassword, encodedPassword      | boolean (matches)                   |
| fetchUser → setUser     | AuthContext | Login/ProtectedRoute | —                            | user в контексте (re-render)        |

================================================================================
Конец документа
================================================================================
